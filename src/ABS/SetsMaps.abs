module ABS.SetsMaps;

// Sets

export *;

// Sets are currently implemented as sorted lists (any implementation

// must yield the same structure regardless of insertion order so that

// set equality via == is preserved).  Using the Insert_ constructor

// directly is strongly discouraged.

data Set<A> = EmptySet | Insert(A, Set<A>);



// set constructor helper

def Set<A> set<A>(List<A> l) = 

    case l { 

       Nil => EmptySet; 

       Cons(x,xs) => insertElement(set(xs), x); 

    };



/**

 * Returns True if set 'ss' contains element 'e', False otherwise.

 */

def Bool contains<A>(Set<A> ss, A e) =

  case ss {

    EmptySet => False ;

    Insert(e, _) => True;

    Insert(x, xs) => if x > e then False else contains(xs, e);

  };

  

/**

 * Returns True if set 'xs' is empty, False  otherwise.

 */

def Bool emptySet<A>(Set<A> xs) = (xs == EmptySet); 



/**

 * Returns the size of set 'xs'.

 */

def Int size<A>(Set<A> xs) = 

   case xs {

      EmptySet => 0 ; 

      Insert(s, ss) => 1 + size(ss); 

   };



/**

 * Returns the union of sets 'set1' and 'set2'.

 */

def Set<A> union<A>(Set<A> set1, Set<A> set2) =

   case set1 {

      EmptySet => set2;

      Insert(e1, ss1) =>  case set2 {

          EmptySet => set1;

          Insert(e1, ss2) => Insert(e1, union(ss1, ss2));

          Insert(e2, ss2) =>

            if e1 < e2

            then Insert(e1, union(ss1, set2))

            else Insert(e2, union(set1, ss2));

      };

   }; 



/**

 * Returns the intersection of sets 'set1' and 'set2'.

 */

def Set<A> intersection<A>(Set<A> set1, Set<A> set2) =

   case set1 {

      EmptySet => EmptySet;

      Insert(e1, ss1) =>  case set2 {

          EmptySet => EmptySet;

          Insert(e1, ss2) => Insert(e1, intersection(ss1, ss2));

          Insert(e2, ss2) =>

            if e1 < e2

            then intersection(ss1, set2)

            else intersection(set1, ss2);

      };

   };



/**

 * Returns the difference of sets 'set1' and 'set2', i.e., all

 * elements of 'set1' that are not in 'set2'.

 */

def Set<A> difference<A>(Set<A> set1, Set<A> set2) =

   case set1 {

      EmptySet => EmptySet;

      Insert(e1, ss1) =>  case set2 {

          EmptySet => set1;

          Insert(e1, ss2) => difference(ss1, ss2);

          Insert(e2, ss2) =>

            if e1 < e2

            then Insert(e1, difference(ss1, set2))

            else difference(set1, ss2);

      };

   };



/**

 * Returns a set with all elements of set 'xs' plus element 'e'.

 * Returns 'xs' if 'xs' already contains 'e'.

 */

def Set<A> insertElement<A>(Set<A> xs, A e) =

  case xs {

      EmptySet => Insert(e, EmptySet);

      Insert(e, _) => xs;

      Insert(x, ss) => if e < x then Insert(e, xs) else Insert(x, insertElement(ss, e));

  };



/**

 * Returns a set with all elements of set 'xs' except element 'e'.

 */

def Set<A> remove<A>(Set<A> xs, A e) = 

  case xs {

     EmptySet => EmptySet ;

     Insert(e, ss) => ss;

     Insert(x, ss) => if e < x then xs else Insert(x, remove(ss, e));

  };



/**

 * Returns one (arbitrary) element from a set.

 * To iterate over a set, take one element and remove it from the set.

 * Repeat until set is empty.

 */

def A take<A>(Set<A> ss) =

  case ss {

    Insert(e, _) => e;

  };



// checks whether the input set has more elements to be iterated.

def Bool hasNext<A>(Set<A> s) = ! emptySet(s); 



// Partial function to iterate over a set.

def Pair<Set<A>,A> next<A>(Set<A> s) = 

   case s { 

      Insert(e, set2) => Pair(set2,e); 

   };


// Maps

data Map<A, B> = EmptyMap | InsertAssoc(Pair<A, B>, Map<A, B>);

 // map constructor helper (does not preserve injectivity)

def Map<A, B> map<A, B>(List<Pair<A, B>> l) =

  case l { 

     Nil => EmptyMap; 

     Cons(hd, tl) => InsertAssoc(hd, map(tl)); 

  };

  

  

def Map<A, B> removeKey<A, B>(Map<A, B> map, A key) = // remove from the map

  case map {

    EmptyMap => map;

    InsertAssoc(Pair(key, _), m) => m;

    InsertAssoc(pair, tail) => InsertAssoc(pair, removeKey(tail, key));

  };

    



def List<B> values<A, B>(Map<A, B> map) =

  case map {

    EmptyMap => Nil ;

    InsertAssoc(Pair(_, elem), tail) => Cons(elem, values(tail)) ;

  };



/**

 * Returns a set containing all keys of map 'map'.

 */

def Set<A> keys<A, B>(Map<A, B> map) =

  case map { 

    EmptyMap => EmptySet ;

    InsertAssoc(Pair(a, _), tail) => insertElement(keys(tail), a); 

  };

    

/**

 * Returns the value associated with key 'k' in map 'ms', or 'Nothing'.

 */

def Maybe<B> lookup<A, B>(Map<A, B> ms, A k) = // retrieve from the map

  case ms {

     InsertAssoc(Pair(k, y), _) => Just(y);

     InsertAssoc(_, tm) => lookup(tm, k);

     EmptyMap => Nothing;

  };



/**

 * Compatibility stub for #342. DEPRECATED!

 */

def Maybe<B> lookupMaybe<A, B>(Map<A, B> ms, A k) = lookup(ms, k);



/**

 * Returns the value associated with key 'k' in map 'ms',

 * or fails if not present.

 */

def B lookupUnsafe<A, B>(Map<A, B> ms, A k) = // retrieve from the map

  fromJust(lookup(ms,k));

  

/**

 * Returns the value associated with key 'k' in map 'ms', or the value 'd'

 * if 'k' has no entry in 'ms'.

 */

def B lookupDefault<A, B>(Map<A, B> ms, A k, B d) = // retrieve from the map

  case ms {

     InsertAssoc(Pair(k, y), _) => y;

     InsertAssoc(_, tm) => lookupDefault(tm, k, d);

     EmptyMap => d;

  };



/**

 * Returns a map with all entries of 'map' plus an entry 'p',

 * which might override but not remove another entry with the same key.

 */

def Map<A, B> insert<A, B>(Map<A, B> map, Pair<A, B> p) = InsertAssoc(p, map);



/**

 * Returns a map with all entries of 'ms' plus an entry mapping 'k' to 'v',

 * minus the first entry already mapping 'k' to a value.

 */  

def Map<A, B> put<A, B>(Map<A, B> ms, A k, B v) =

  case ms {

    EmptyMap => InsertAssoc(Pair(k, v),EmptyMap);

    InsertAssoc(Pair(k, _), ts) => InsertAssoc(Pair(k, v), ts);

    InsertAssoc(p, ts) => InsertAssoc(p, put(ts, k, v));

  };